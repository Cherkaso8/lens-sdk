"""
The comparison operator to use. In case of boolean functions you can only use EQUAL or NOT_EQUAL
"""
enum AccessConditionComparison {
  EQUAL
  NOT_EQUAL
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN
  LESS_THAN_OR_EQUAL
}

"""AccessConditionType"""
union AccessConditionType = NftOwnershipCondition | Erc20OwnershipCondition | EoaOwnershipCondition | ProfileOwnershipCondition | FollowCondition | CollectCondition | AdvancedContractCondition

scalar AccessToken

type Account {
  address: EvmAddress!
  score: Int!
  metadata: AccountMetadata
  username: UsernameValue
  operations: LoggedInAccountOperations
}

input AccountAuthenticationsRequest {
  app: EvmAddress
  pageSize: PageSize
  cursor: Cursor
}

type AccountBlocked {
  account: Account!
  blockedAt: DateTime!
}

type AccountFeedsStats {
  posts: Int!
  comments: Int!
  reposts: Int!
  quotes: Int!
  reacted: Int!
  reactions: Int!
  collects: Int!
}

input AccountFeedsStatsRequest {
  account: EvmAddress!
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
}

type AccountFollowRuleError {
  error: AccountFollowRuleErrorType!
}

enum AccountFollowRuleErrorType {
  UNKNOWN
}

union AccountFollowRuleResult = SetAccountFollowRuleResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | AccountFollowRuleError

type AccountGraphsFollowStats {
  followers: Int!
  following: Int!
}

input AccountGraphsStatsRequest {
  account: EvmAddress!
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
}

type AccountManaged {
  account: Account!
  addedAt: DateTime!
}

type AccountManager {
  address: EvmAddress!
  isLensManager: Boolean!
  addedAt: DateTime!
}

input AccountManagersRequest {
  pageSize: PageSize
  cursor: Cursor
}

type AccountMetadata {
  """
  The App Id that this Profile data refers to. If omitted the data is considered to be the
  global Profile data.
  """
  appId: AppId

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """The profile bio as markdown."""
  bio: String

  """The profile cover picture."""
  coverPicture: URI

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """The profile display name."""
  name: String

  """The profile picture."""
  picture: URI
}

type AccountPostReaction {
  account: Account!
  reactions: [PostReaction!]!
}

enum AccountReportReason {
  IMPERSONATION
  REPETITIVE_SPAM
  OTHER
}

input AccountRequest {
  address: EvmAddress
  username: UsernameValue
  legacyProfileId: LegacyProfileId
}

enum AccountSearchOrderBy {
  USERNAME_PREFIX_ORDER
  ACCOUNT_SCORE
}

input AccountSearchRequest {
  limit: Int
  cursor: Cursor
  query: String!
  namespace: [String!]
  orderBy: AccountSearchOrderBy
}

type AccountSponsorLimit {
  window: SponsorLimitType!
  allowanceLeft: Int!
  allowanceUsed: Int!
  allowance: Int!
}

input AccountSponsorRequest {
  account: EvmAddress!
  appOrSponsor: EvmAddress
}

type AccountSponsorResult {
  global: AccountSponsorLimit
  user: AccountSponsorLimit
}

type AccountStats {
  feedStats: AccountFeedsStats!
  graphFollowStats: AccountGraphsFollowStats!
}

input AccountStatsRequest {
  account: EvmAddress!
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
}

type AccountUsername {
  id: String
  value: UsernameValue!
  prefix: String!
  localName: String!
  linkedTo: EvmAddress
  ownedBy: EvmAddress!
}

input AccountUsernameRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
}

input AccountsBlockedRequest {
  pageSize: PageSize
  cursor: Cursor
}

input AccountsManagedRequest {
  pageSize: PageSize
  cursor: Cursor
  managedBy: EvmAddress!
  includeOwned: Boolean
  hiddenFilter: ManagedAccountsVisibility
}

input AccountsRequest {
  addresses: [EvmAddress!]
  usernames: [UsernameValue!]
  legacyProfileIds: [LegacyProfileId!]
}

input ActionFilter {
  address: EvmAddress
  actionType: PostActionType
  category: PostActionCategoryType
}

union ActionInfo = KnownAction | UnknownAction

type ActionInputInfo {
  name: String!
  type: String!
}

type ActiveAuthentication {
  authenticationId: UUID!
  app: EvmAddress!
  browser: String
  device: String
  os: String
  origin: URL
  signer: EvmAddress!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AddReactionFailure {
  reason: String!
}

input AddReactionRequest {
  """The reaction to add."""
  reaction: PostReactionType!

  """The post to react to."""
  postId: PostId!
}

type AddReactionResponse {
  success: Boolean!
}

union AddReactionResult = AddReactionResponse | AddReactionFailure

type AdvancedContractCondition {
  """
  The contract ABI. Has to be in human readable single string format containing the signature of the function you want to call. See https://docs.ethers.org/v5/api/utils/abi/formats/#abi-formats--human-readable-abi for more info
  """
  abi: String!

  """
  The comparison operator to use. In case of boolean functions you can only use EQUAL or
  NOT_EQUAL
  """
  comparison: AccessConditionComparison!
  contract: NetworkAddress!

  """The name of the function you want to call"""
  functionName: String!

  """
  The parameters to pass to the function. Must be exactly matching the function arguments.
  You *must* pass in the `:userAddress` parameter to represent the decrypter address. Any
  array or tuple arguments, must be stringified JSON arrays.
  """
  params: [String!]!
  type: String!

  """The comparison value. Accepts 'true', 'false' or a number"""
  value: AdvancedContractConditionValue!
}

scalar AdvancedContractConditionValue

type Amount {
  asset: Asset!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!
}

input AmountInput {
  """
  The token address. To represent the native token, use the
  0x000000000000000000000000000000000000800a.
  """
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!
}

"""AccessConditionCriteriaItem"""
union AnyAccessCondition = BooleanAndCondition | BooleanOrCondition | CollectCondition | AdvancedContractCondition | EoaOwnershipCondition | Erc20OwnershipCondition | FollowCondition | NftOwnershipCondition | ProfileOwnershipCondition

"""
AnyMedia

<details><summary>JSON schema</summary>

```json
{
"anyOf": [
{
"$ref": "#/$defs/MediaAudio"
},
{
"$ref": "#/$defs/MediaImage"
},
{
"$ref": "#/$defs/MediaVideo"
}
]
}
```
</details>
"""
union AnyMedia = MediaAudio | MediaImage | MediaVideo

union AnyPost = Post | Repost

type App {
  address: EvmAddress!
  graphAddress: EvmAddress
  sponsorshipAddress: EvmAddress
  defaultFeedAddress: EvmAddress
  usernameAddress: EvmAddress
  treasuryAddress: EvmAddress
  createdAt: DateTime!
  metadata: AppMetadata
}

scalar AppId

type AppMetadata {
  """
  An optional short and detailed description of the app, explaining its features and purpose.
  """
  description: String

  """The Developer of the app."""
  developer: String!

  """The Logo icon for the app."""
  logo: URI

  """The name of the app."""
  name: String!

  """The platforms supported by the app."""
  platforms: [AppMetadataLensPlatformsItem!]!

  """The privacy policy for the app."""
  privacyPolicy: URI

  """The terms of service for the app."""
  termsOfService: URI

  """The url of the app."""
  url: String!
}

enum AppMetadataLensPlatformsItem {
  WEB
  IOS
  ANDROID
}

input AppRequest {
  app: EvmAddress!
}

enum AppsOrderBy {
  ALPHABETICAL
  LATEST_FIRST
  OLDEST_FIRST
}

input AppsRequest {
  pageSize: PageSize
  cursor: Cursor
  orderBy: AppsOrderBy! = LATEST_FIRST
}

type ArticleMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """Any attachment you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  content: Encryptable!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional article title."""
  title: String
}

union Asset = Erc20

type AssignUsernameToAccountError {
  error: AssignUsernameToAccountErrorType!
}

enum AssignUsernameToAccountErrorType {
  UNKNOWN
  USERNAME_ALREADY_ASSIGNED
  INVALID_USERNAME
  UNAUTHORIZED
}

input AssignUsernameToAccountRequest {
  usernameAddress: EvmAddress!
  accountUsernameId: String!
}

type AssignUsernameToAccountResponse {
  hash: TxHash!
}

union AssignUsernameToAccountResult = AssignUsernameToAccountResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | AssignUsernameToAccountError

type AudioMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  audio: MediaAudio!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional audio title."""
  title: String
  content: Encryptable!
}

type AuthenticationChallenge {
  id: UUID!
  text: String!
  app: App!
}

union AuthenticationResult = AuthenticationTokens | WrongSignerError | ExpiredChallengeError | ForbiddenError

type AuthenticationTokens {
  """
  The Access Token to use as a Bearer token in authenticated Lens API requests.
  """
  accessToken: AccessToken!

  """
  The Refresh Token to use to obtain a new tokens triplet without re-authenticating.
  """
  refreshToken: RefreshToken!
  idToken: IdToken!
}

scalar BigDecimal

scalar BigInt

type BlockError {
  error: BlockErrorType!
}

enum BlockErrorType {
  UNKNOWN
  ALREADY_BLOCKED
  UNAUTHORIZED
}

input BlockRequest {
  account: EvmAddress!
}

type BlockResponse {
  hash: TxHash!
}

union BlockResult = BlockResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | BlockError

scalar BlockchainData

input BookmarkPostRequest {
  postId: PostId!
}

type BooleanAndCondition {
  criteria: [AccessConditionType!]!
  type: String!
}

type BooleanOrCondition {
  criteria: [AccessConditionType!]!
  type: String!
}

type BooleanValue {
  optimistic: Boolean!
  onChain: Boolean!
}

input CanFollowRequest {
  graph: EvmAddress!
}

input CanUnfollowRequest {
  graph: EvmAddress!
}

scalar ChainId

input ChallengeRequest {
  account: EvmAddress!
  app: EvmAddress!
  signedBy: EvmAddress!
}

type CheckingInMetadata {
  """The optional address of the location."""
  address: PhysicalAddress

  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """Where you checking in from (free form text)."""
  location: Encryptable!

  """The main focus of the publication."""
  mainContentFocus: String!

  """The optional geographic position of the location."""
  position: Encryptable

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

input CollectActionInput {
  simpleCollectAction: SimpleCollectActionInput
}

"""CollectCondition"""
type CollectCondition {
  publicationId: PostId!
  thisPublication: Boolean!
  type: String!
}

enum ContentWarning {
  NSFW
  SENSITIVE
  SPOILER
}

input CreateAccountFollowRuleRequest {
  account: EvmAddress!
  graph: EvmAddress
  rule: FollowRulesInput!
}

type CreateAccountResponse {
  hash: TxHash!
}

input CreateAccountWithUsernameRequest {
  """The account metadata uri"""
  metadataUri: URI!

  """The local name to create should not include the namespace"""
  localName: String!

  """Any account managers you wish to add to the account"""
  accountManager: [EvmAddress!]!
}

union CreateAccountWithUsernameResult = CreateAccountResponse | InvalidUsername | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input CreateFollowRequest {
  """The account to follow."""
  account: EvmAddress!

  """
  The graph to follow the account on. If not provided, the global graph is used.
  """
  graph: EvmAddress! = "0x7bE2cA3B7be499546f3f31605f4818D70d14439A"

  """
  The data required by any follow rules associated with the account being followed.
  """
  followRule: FollowRulesInput

  """
  The data required by the graph rules associated with the specified graph.
  """
  graphRule: GraphRulesInput
}

type CreateFrameEIP712TypedData {
  types: CreateFrameEIP712TypedDataTypes!
  domain: Eip712TypedDataDomain!
  value: CreateFrameEIP712TypedDataValue!
}

input CreateFrameEIP712TypedDataInput {
  types: CreateFrameEIP712TypedDataTypesInput!
  domain: Eip712TypedDataDomainInput!
  value: CreateFrameEIP712TypedDataValueInput!
}

type CreateFrameEIP712TypedDataTypes {
  frameData: [Eip712TypedDataField!]!
}

input CreateFrameEIP712TypedDataTypesInput {
  frameData: [Eip712TypedDataFieldInput!]!
}

type CreateFrameEIP712TypedDataValue {
  specVersion: String!
  url: URI!
  buttonIndex: Int!
  account: EvmAddress!
  postId: PostId!
  inputText: String!
  state: String!
  actionResponse: String!
  deadline: Int!
}

input CreateFrameEIP712TypedDataValueInput {
  specVersion: String!
  url: URI!
  buttonIndex: Int!
  account: EvmAddress!
  postId: PostId!
  inputText: String!
  state: String!
  actionResponse: String!
  deadline: Int!
}

input CreatePostRequest {
  """The feed to post to. If not provided, the global feed is used."""
  feed: EvmAddress! = "0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"

  """The URI of the post metadata."""
  contentUri: URI!

  """The post to quote, if any."""
  quoteOf: ReferencingPostInput

  """The post to comment on, if any."""
  commentOn: ReferencingPostInput

  """The actions to attach to the post."""
  actions: [PostActionInput!]
}

input CreateRepostRequest {
  """The feed to repost to. If not provided, the global feed is used."""
  feed: EvmAddress! = "0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"

  """The post to reference."""
  post: PostId!
}

input CreateUnfollowRequest {
  """The account to unfollow."""
  account: EvmAddress!

  """
  The graph where the account is followed and should be unfollowed.
  If not provided, the global graph is used.
  """
  graph: EvmAddress! = "0x7bE2cA3B7be499546f3f31605f4818D70d14439A"

  """
  The data required by the graph rules associated with the specified graph.
  """
  graphRule: GraphRulesInput
}

input CurrencyRequest {
  limit: Int
  cursor: Cursor
  verified: Boolean
}

scalar Cursor

scalar DateTime

input DebugPostMetadataRequest {
  rawUri: URI
  json: String
  source: EntityType!
}

type DebugPostMetadataResult {
  valid: Boolean!
  reason: String
}

input DebugTransactionStatusRequest {
  txHash: TxHash!
}

type DebugTransactionStatusResult {
  blockExplorer: URI
  reason: String!
}

input DeletePostRequest {
  """The post to delete."""
  post: PostId!

  """If needed, the feed rule data required to accomplish the deletion."""
  feedRules: FeedRulesInput
}

type DeletePostResponse {
  hash: TxHash!
}

union DeletePostResult = DeletePostResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input DismissRecommendedAccountsRequest {
  accounts: [EvmAddress!]!
}

type DisputedReport {
  createdAt: DateTime!
  reporter: Account!
  reportedAccount: Account!
  reportReason: String!
  reportSubreason: String!
  reportAdditionalInfo: String!
  reportedPost: Post
  disputer: Account!
  disputeReason: String!
}

input EditPostRequest {
  post: PostId!
  contentUri: URI!
}

type Eip1559TransactionRequest {
  """The transaction type: 2 for EIP-1559 transactions."""
  type: Int!

  """The target of the transaction."""
  to: EvmAddress!

  """The sender of the transaction."""
  from: EvmAddress!

  """The nonce of the transaction, used to prevent replay attacks."""
  nonce: Int!

  """The maximum amount of gas to allow this transaction to consume."""
  gasLimit: Int!

  """The EIP_1559 maximum priority fee to pay per gas."""
  maxPriorityFeePerGas: BigInt!

  """
  The EIP_1559 maximum total fee to pay per gas. The actual
  value used is protocol enforced to be the block's base fee.
  """
  maxFeePerGas: BigInt!

  """The transaction data."""
  data: BlockchainData!

  """The transaction value (in wei)."""
  value: BigInt

  """The chain ID for the network this transaction is valid on."""
  chainId: Int!
}

"""Contains EIP-712 transaction metadata."""
type Eip712Meta {
  """
  The maximum amount of gas the user is willing to pay for a single byte of pubdata.
  """
  gasPerPubdata: BigInt!

  """
  An array of bytes containing the bytecode of the contract being deployed and any related
  contracts it can deploy.
  """
  factoryDeps: [BlockchainData!]!

  """
  Custom signature used for cases where the signer's account is not an EOA.
  """
  customSignature: BlockchainData

  """Parameters for configuring the custom paymaster for the transaction."""
  paymasterParams: PaymasterParams
}

type Eip712TransactionRequest {
  """The transaction type: 113 for EIP-712 transactions."""
  type: Int!

  """The target of the transaction."""
  to: EvmAddress!

  """The sender of the transaction."""
  from: EvmAddress!

  """The nonce of the transaction, used to prevent replay attacks."""
  nonce: Int!

  """The maximum amount of gas to allow this transaction to consume."""
  gasLimit: Int!

  """The gas price to use."""
  gasPrice: BigInt!

  """The transaction data."""
  data: BlockchainData!

  """The transaction value (in wei)."""
  value: BigInt

  """The chain ID for the network this transaction is valid on."""
  chainId: Int!

  """The custom data for EIP-712 transaction metadata."""
  customData: Eip712Meta!
}

type Eip712TypedDataDomain {
  name: String!
  chainId: Int!
  version: String!
  verifyingContract: EvmAddress!
}

input Eip712TypedDataDomainInput {
  name: String!
  chainId: Int!
  version: String!
  verifyingContract: EvmAddress!
}

type Eip712TypedDataField {
  name: String!
  type: String!
}

input Eip712TypedDataFieldInput {
  name: String!
  type: String!
}

type EmbedMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning

  """The embed URL."""
  embed: Encryptable!
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

scalar EncodedTransaction

scalar Encryptable

union EncryptionStrategy = LitProtocolEncryptionStrategy

enum EntityType {
  ACCOUNT
  GRAPH
  FEED
  USERNAME
  GROUP
  POST
  APP
  SPONSORSHIP
}

"""EoaOwnershipCondition"""
type EoaOwnershipCondition {
  address: EvmAddress!
  type: String!
}

type Erc20 {
  name: String!
  symbol: String!
  decimals: Int!
  contract: NetworkAddress!
}

"""Erc20OwnershipCondition"""
type Erc20OwnershipCondition {
  amount: Amount!
  condition: AccessConditionComparison!
  type: String!
}

type EventMetadata {
  """The address of the event."""
  address: PhysicalAddress

  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """The event end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  endsAt: Encryptable!

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!

  """The links you want to include with it."""
  links: [Encryptable!]!
  locale: Locale!

  """The location of the event."""
  location: EventMetadataLensLocation!

  """The main focus of the publication."""
  mainContentFocus: String!

  """The geographic position of the event."""
  position: Encryptable
  schedulingAdjustments: EventMetadataLensSchedulingAdjustments

  """The event start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The title of the event."""
  title: String
  content: Encryptable!
}

type EventMetadataLensLocation {
  physical: Encryptable
  virtual: Encryptable
}

type EventMetadataLensSchedulingAdjustments {
  """
  Indicates a reference timezone for the event start and end times. If physical event, you
  could use the timezone of the event location. If virtual event, the timezone of the event
  organizer.
  """
  timezoneId: EventMetadataLensSchedulingAdjustmentsTimezoneId!
  timezoneOffset: Float!
}

enum EventMetadataLensSchedulingAdjustmentsTimezoneId {
  AFRICA_ABIDJAN
  AFRICA_ACCRA
  AFRICA_ADDIS_ABABA
  AFRICA_ALGIERS
  AFRICA_ASMERA
  AFRICA_BAMAKO
  AFRICA_BANGUI
  AFRICA_BANJUL
  AFRICA_BISSAU
  AFRICA_BLANTYRE
  AFRICA_BRAZZAVILLE
  AFRICA_BUJUMBURA
  AFRICA_CAIRO
  AFRICA_CASABLANCA
  AFRICA_CEUTA
  AFRICA_CONAKRY
  AFRICA_DAKAR
  AFRICA_DAR_ES_SALAAM
  AFRICA_DJIBOUTI
  AFRICA_DOUALA
  AFRICA_EL_AAIUN
  AFRICA_FREETOWN
  AFRICA_GABORONE
  AFRICA_HARARE
  AFRICA_JOHANNESBURG
  AFRICA_JUBA
  AFRICA_KAMPALA
  AFRICA_KHARTOUM
  AFRICA_KIGALI
  AFRICA_KINSHASA
  AFRICA_LAGOS
  AFRICA_LIBREVILLE
  AFRICA_LOME
  AFRICA_LUANDA
  AFRICA_LUBUMBASHI
  AFRICA_LUSAKA
  AFRICA_MALABO
  AFRICA_MAPUTO
  AFRICA_MASERU
  AFRICA_MBABANE
  AFRICA_MOGADISHU
  AFRICA_MONROVIA
  AFRICA_NAIROBI
  AFRICA_NDJAMENA
  AFRICA_NIAMEY
  AFRICA_NOUAKCHOTT
  AFRICA_OUAGADOUGOU
  AFRICA_PORTO_NOVO
  AFRICA_SAO_TOME
  AFRICA_TRIPOLI
  AFRICA_TUNIS
  AFRICA_WINDHOEK
  AMERICA_ADAK
  AMERICA_ANCHORAGE
  AMERICA_ANGUILLA
  AMERICA_ANTIGUA
  AMERICA_ARAGUAINA
  AMERICA_ARGENTINA_LA_RIOJA
  AMERICA_ARGENTINA_RIO_GALLEGOS
  AMERICA_ARGENTINA_SALTA
  AMERICA_ARGENTINA_SAN_JUAN
  AMERICA_ARGENTINA_SAN_LUIS
  AMERICA_ARGENTINA_TUCUMAN
  AMERICA_ARGENTINA_USHUAIA
  AMERICA_ARUBA
  AMERICA_ASUNCION
  AMERICA_BAHIA
  AMERICA_BAHIA_BANDERAS
  AMERICA_BARBADOS
  AMERICA_BELEM
  AMERICA_BELIZE
  AMERICA_BLANC_SABLON
  AMERICA_BOA_VISTA
  AMERICA_BOGOTA
  AMERICA_BOISE
  AMERICA_BUENOS_AIRES
  AMERICA_CAMBRIDGE_BAY
  AMERICA_CAMPO_GRANDE
  AMERICA_CANCUN
  AMERICA_CARACAS
  AMERICA_CATAMARCA
  AMERICA_CAYENNE
  AMERICA_CAYMAN
  AMERICA_CHICAGO
  AMERICA_CHIHUAHUA
  AMERICA_CIUDAD_JUAREZ
  AMERICA_CORAL_HARBOUR
  AMERICA_CORDOBA
  AMERICA_COSTA_RICA
  AMERICA_CRESTON
  AMERICA_CUIABA
  AMERICA_CURACAO
  AMERICA_DANMARKSHAVN
  AMERICA_DAWSON
  AMERICA_DAWSON_CREEK
  AMERICA_DENVER
  AMERICA_DETROIT
  AMERICA_DOMINICA
  AMERICA_EDMONTON
  AMERICA_EIRUNEPE
  AMERICA_EL_SALVADOR
  AMERICA_FORT_NELSON
  AMERICA_FORTALEZA
  AMERICA_GLACE_BAY
  AMERICA_GODTHAB
  AMERICA_GOOSE_BAY
  AMERICA_GRAND_TURK
  AMERICA_GRENADA
  AMERICA_GUADELOUPE
  AMERICA_GUATEMALA
  AMERICA_GUAYAQUIL
  AMERICA_GUYANA
  AMERICA_HALIFAX
  AMERICA_HAVANA
  AMERICA_HERMOSILLO
  AMERICA_INDIANA_KNOX
  AMERICA_INDIANA_MARENGO
  AMERICA_INDIANA_PETERSBURG
  AMERICA_INDIANA_TELL_CITY
  AMERICA_INDIANA_VEVAY
  AMERICA_INDIANA_VINCENNES
  AMERICA_INDIANA_WINAMAC
  AMERICA_INDIANAPOLIS
  AMERICA_INUVIK
  AMERICA_IQALUIT
  AMERICA_JAMAICA
  AMERICA_JUJUY
  AMERICA_JUNEAU
  AMERICA_KENTUCKY_MONTICELLO
  AMERICA_KRALENDIJK
  AMERICA_LA_PAZ
  AMERICA_LIMA
  AMERICA_LOS_ANGELES
  AMERICA_LOUISVILLE
  AMERICA_LOWER_PRINCES
  AMERICA_MACEIO
  AMERICA_MANAGUA
  AMERICA_MANAUS
  AMERICA_MARIGOT
  AMERICA_MARTINIQUE
  AMERICA_MATAMOROS
  AMERICA_MAZATLAN
  AMERICA_MENDOZA
  AMERICA_MENOMINEE
  AMERICA_MERIDA
  AMERICA_METLAKATLA
  AMERICA_MEXICO_CITY
  AMERICA_MIQUELON
  AMERICA_MONCTON
  AMERICA_MONTERREY
  AMERICA_MONTEVIDEO
  AMERICA_MONTSERRAT
  AMERICA_NASSAU
  AMERICA_NEW_YORK
  AMERICA_NIPIGON
  AMERICA_NOME
  AMERICA_NORONHA
  AMERICA_NORTH_DAKOTA_BEULAH
  AMERICA_NORTH_DAKOTA_CENTER
  AMERICA_NORTH_DAKOTA_NEW_SALEM
  AMERICA_OJINAGA
  AMERICA_PANAMA
  AMERICA_PANGNIRTUNG
  AMERICA_PARAMARIBO
  AMERICA_PHOENIX
  AMERICA_PORT_AU_PRINCE
  AMERICA_PORT_OF_SPAIN
  AMERICA_PORTO_VELHO
  AMERICA_PUERTO_RICO
  AMERICA_PUNTA_ARENAS
  AMERICA_RAINY_RIVER
  AMERICA_RANKIN_INLET
  AMERICA_RECIFE
  AMERICA_REGINA
  AMERICA_RESOLUTE
  AMERICA_RIO_BRANCO
  AMERICA_SANTA_ISABEL
  AMERICA_SANTAREM
  AMERICA_SANTIAGO
  AMERICA_SANTO_DOMINGO
  AMERICA_SAO_PAULO
  AMERICA_SCORESBYSUND
  AMERICA_SITKA
  AMERICA_ST_BARTHELEMY
  AMERICA_ST_JOHNS
  AMERICA_ST_KITTS
  AMERICA_ST_LUCIA
  AMERICA_ST_THOMAS
  AMERICA_ST_VINCENT
  AMERICA_SWIFT_CURRENT
  AMERICA_TEGUCIGALPA
  AMERICA_THULE
  AMERICA_THUNDER_BAY
  AMERICA_TIJUANA
  AMERICA_TORONTO
  AMERICA_TORTOLA
  AMERICA_VANCOUVER
  AMERICA_WHITEHORSE
  AMERICA_WINNIPEG
  AMERICA_YAKUTAT
  AMERICA_YELLOWKNIFE
  ANTARCTICA_CASEY
  ANTARCTICA_DAVIS
  ANTARCTICA_DUMONT_D_URVILLE
  ANTARCTICA_MACQUARIE
  ANTARCTICA_MAWSON
  ANTARCTICA_MC_MURDO
  ANTARCTICA_PALMER
  ANTARCTICA_ROTHERA
  ANTARCTICA_SYOWA
  ANTARCTICA_TROLL
  ANTARCTICA_VOSTOK
  ARCTIC_LONGYEARBYEN
  ASIA_ADEN
  ASIA_ALMATY
  ASIA_AMMAN
  ASIA_ANADYR
  ASIA_AQTAU
  ASIA_AQTOBE
  ASIA_ASHGABAT
  ASIA_ATYRAU
  ASIA_BAGHDAD
  ASIA_BAHRAIN
  ASIA_BAKU
  ASIA_BANGKOK
  ASIA_BARNAUL
  ASIA_BEIRUT
  ASIA_BISHKEK
  ASIA_BRUNEI
  ASIA_CALCUTTA
  ASIA_CHITA
  ASIA_CHOIBALSAN
  ASIA_COLOMBO
  ASIA_DAMASCUS
  ASIA_DHAKA
  ASIA_DILI
  ASIA_DUBAI
  ASIA_DUSHANBE
  ASIA_FAMAGUSTA
  ASIA_GAZA
  ASIA_HEBRON
  ASIA_HONG_KONG
  ASIA_HOVD
  ASIA_IRKUTSK
  ASIA_JAKARTA
  ASIA_JAYAPURA
  ASIA_JERUSALEM
  ASIA_KABUL
  ASIA_KAMCHATKA
  ASIA_KARACHI
  ASIA_KATMANDU
  ASIA_KHANDYGA
  ASIA_KRASNOYARSK
  ASIA_KUALA_LUMPUR
  ASIA_KUCHING
  ASIA_KUWAIT
  ASIA_MACAU
  ASIA_MAGADAN
  ASIA_MAKASSAR
  ASIA_MANILA
  ASIA_MUSCAT
  ASIA_NICOSIA
  ASIA_NOVOKUZNETSK
  ASIA_NOVOSIBIRSK
  ASIA_OMSK
  ASIA_ORAL
  ASIA_PHNOM_PENH
  ASIA_PONTIANAK
  ASIA_PYONGYANG
  ASIA_QATAR
  ASIA_QOSTANAY
  ASIA_QYZYLORDA
  ASIA_RANGOON
  ASIA_RIYADH
  ASIA_SAIGON
  ASIA_SAKHALIN
  ASIA_SAMARKAND
  ASIA_SEOUL
  ASIA_SHANGHAI
  ASIA_SINGAPORE
  ASIA_SREDNEKOLYMSK
  ASIA_TAIPEI
  ASIA_TASHKENT
  ASIA_TBILISI
  ASIA_TEHRAN
  ASIA_THIMPHU
  ASIA_TOKYO
  ASIA_TOMSK
  ASIA_ULAANBAATAR
  ASIA_URUMQI
  ASIA_UST_NERA
  ASIA_VIENTIANE
  ASIA_VLADIVOSTOK
  ASIA_YAKUTSK
  ASIA_YEKATERINBURG
  ASIA_YEREVAN
  ATLANTIC_AZORES
  ATLANTIC_BERMUDA
  ATLANTIC_CANARY
  ATLANTIC_CAPE_VERDE
  ATLANTIC_FAEROE
  ATLANTIC_MADEIRA
  ATLANTIC_REYKJAVIK
  ATLANTIC_SOUTH_GEORGIA
  ATLANTIC_ST_HELENA
  ATLANTIC_STANLEY
  AUSTRALIA_ADELAIDE
  AUSTRALIA_BRISBANE
  AUSTRALIA_BROKEN_HILL
  AUSTRALIA_CURRIE
  AUSTRALIA_DARWIN
  AUSTRALIA_EUCLA
  AUSTRALIA_HOBART
  AUSTRALIA_LINDEMAN
  AUSTRALIA_LORD_HOWE
  AUSTRALIA_MELBOURNE
  AUSTRALIA_PERTH
  AUSTRALIA_SYDNEY
  EUROPE_AMSTERDAM
  EUROPE_ANDORRA
  EUROPE_ASTRAKHAN
  EUROPE_ATHENS
  EUROPE_BELGRADE
  EUROPE_BERLIN
  EUROPE_BRATISLAVA
  EUROPE_BRUSSELS
  EUROPE_BUCHAREST
  EUROPE_BUDAPEST
  EUROPE_BUSINGEN
  EUROPE_CHISINAU
  EUROPE_COPENHAGEN
  EUROPE_DUBLIN
  EUROPE_GIBRALTAR
  EUROPE_GUERNSEY
  EUROPE_HELSINKI
  EUROPE_ISLE_OF_MAN
  EUROPE_ISTANBUL
  EUROPE_JERSEY
  EUROPE_KALININGRAD
  EUROPE_KIEV
  EUROPE_KIROV
  EUROPE_LISBON
  EUROPE_LJUBLJANA
  EUROPE_LONDON
  EUROPE_LUXEMBOURG
  EUROPE_MADRID
  EUROPE_MALTA
  EUROPE_MARIEHAMN
  EUROPE_MINSK
  EUROPE_MONACO
  EUROPE_MOSCOW
  EUROPE_OSLO
  EUROPE_PARIS
  EUROPE_PODGORICA
  EUROPE_PRAGUE
  EUROPE_RIGA
  EUROPE_ROME
  EUROPE_SAMARA
  EUROPE_SAN_MARINO
  EUROPE_SARAJEVO
  EUROPE_SARATOV
  EUROPE_SIMFEROPOL
  EUROPE_SKOPJE
  EUROPE_SOFIA
  EUROPE_STOCKHOLM
  EUROPE_TALLINN
  EUROPE_TIRANE
  EUROPE_ULYANOVSK
  EUROPE_UZHGOROD
  EUROPE_VADUZ
  EUROPE_VATICAN
  EUROPE_VIENNA
  EUROPE_VILNIUS
  EUROPE_VOLGOGRAD
  EUROPE_WARSAW
  EUROPE_ZAGREB
  EUROPE_ZAPOROZHYE
  EUROPE_ZURICH
  INDIAN_ANTANANARIVO
  INDIAN_CHAGOS
  INDIAN_CHRISTMAS
  INDIAN_COCOS
  INDIAN_COMORO
  INDIAN_KERGUELEN
  INDIAN_MAHE
  INDIAN_MALDIVES
  INDIAN_MAURITIUS
  INDIAN_MAYOTTE
  INDIAN_REUNION
  PACIFIC_APIA
  PACIFIC_AUCKLAND
  PACIFIC_BOUGAINVILLE
  PACIFIC_CHATHAM
  PACIFIC_EASTER
  PACIFIC_EFATE
  PACIFIC_ENDERBURY
  PACIFIC_FAKAOFO
  PACIFIC_FIJI
  PACIFIC_FUNAFUTI
  PACIFIC_GALAPAGOS
  PACIFIC_GAMBIER
  PACIFIC_GUADALCANAL
  PACIFIC_GUAM
  PACIFIC_HONOLULU
  PACIFIC_JOHNSTON
  PACIFIC_KIRITIMATI
  PACIFIC_KOSRAE
  PACIFIC_KWAJALEIN
  PACIFIC_MAJURO
  PACIFIC_MARQUESAS
  PACIFIC_MIDWAY
  PACIFIC_NAURU
  PACIFIC_NIUE
  PACIFIC_NORFOLK
  PACIFIC_NOUMEA
  PACIFIC_PAGO_PAGO
  PACIFIC_PALAU
  PACIFIC_PITCAIRN
  PACIFIC_PONAPE
  PACIFIC_PORT_MORESBY
  PACIFIC_RAROTONGA
  PACIFIC_SAIPAN
  PACIFIC_TAHITI
  PACIFIC_TARAWA
  PACIFIC_TONGATAPU
  PACIFIC_TRUK
  PACIFIC_WAKE
  PACIFIC_WALLIS
}

scalar EvmAddress

"""The challenge has expired or was not found."""
type ExpiredChallengeError {
  reason: String!
}

"""
The transaction has failed to be mined or indexed.

The reason for the failure is provided.
"""
type FailedTransactionStatus {
  reason: String!
  blockTimestamp: DateTime!
}

input FeeFollowRuleInput {
  amount: AmountInput!
}

type Feed {
  address: EvmAddress!
}

input FeedRequest {
  feed: EvmAddress!
}

input FeedRulesInput {
  unknownFeedRule: UnknownFeedRuleInput
}

"""
The transaction has been mined and indexed correctly.

If the transaction involves any metadata, the metadata has been snapshotted and indexed.
"""
type FinishedTransactionStatus {
  blockTimestamp: DateTime!
}

"""FollowCondition"""
type FollowCondition {
  follow: EvmAddress!
  type: String!
}

input FollowPair {
  graph: EvmAddress!
  follower: EvmAddress!
  account: EvmAddress!
}

type FollowResponse {
  hash: TxHash!
}

union FollowResult = FollowResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type FollowRule {
  moduleName: String!
  contract: NetworkAddress!
}

input FollowRulesInput {
  feeFollowRule: FeeFollowRuleInput
  unknownFollowRule: UnknownFollowRuleInput
}

input FollowRulesRequest {
  limit: Int
  cursor: Cursor
  includeUnknown: Boolean
  onlyVerified: Boolean
}

input FollowStatusRequest {
  pairs: [FollowPair!]!
}

type FollowStatusResult {
  graph: EvmAddress!
  follower: EvmAddress!
  account: EvmAddress!
  isFollowing: BooleanValue!
}

enum FollowersOrderBy {
  APPS_OR_GRAPHS_FILTER_ORDER
  ACCOUNT_SCORE
}

input FollowersRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
  orderBy: FollowersOrderBy
}

enum FollowersYouKnowOrderBy {
  APPS_OR_GRAPHS_FILTER_ORDER
  ACCOUNT_SCORE
}

input FollowersYouKnowRequest {
  limit: Int
  cursor: Cursor
  target: EvmAddress!
  observer: EvmAddress!
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
  orderBy: FollowersYouKnowOrderBy
}

enum FollowingOrderBy {
  APPS_OR_GRAPHS_FILTER_ORDER
  ACCOUNT_SCORE
}

input FollowingRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
  orderBy: FollowingOrderBy
}

enum ForYouSource {
  FOLLOWING
  CURATED
  POPULAR
  EXTENDED_NETWORK
}

type ForbiddenError {
  reason: String!
}

input FrameEIP712Request {
  specVersion: String!
  url: URI!
  buttonIndex: Int!
  account: EvmAddress!
  postId: PostId!
  inputText: String!
  state: String!
  actionResponse: String!
  deadline: Int!
}

input FrameLensManagerEIP712Request {
  specVersion: String!
  url: URI!
  buttonIndex: Int!
  account: EvmAddress!
  postId: PostId!
  inputText: String!
  state: String!
  actionResponse: String!
}

type FrameLensManagerSignatureResult {
  signedTypedData: CreateFrameEIP712TypedData!
  signature: Signature!
}

input FrameVerifySignature {
  signedTypedData: CreateFrameEIP712TypedDataInput!
  signature: Signature!
  identityToken: IdToken!
}

enum FrameVerifySignatureResult {
  VERIFIED
  IDENTITY_UNAUTHORIZED
  IDENTITY_CANNOT_USE_PROFILE
  DEADLINE_EXPIRED
  SIGNER_ADDRESS_CANNOT_USE_PROFILE
}

type Graph {
  address: EvmAddress!
  metadata: GraphMetadata
}

type GraphMetadata {
  """Optional markdown formatted description of the graph."""
  description: String

  """The name of the graph."""
  name: String!

  """The human-friendly title for the graph."""
  title: String!
}

input GraphRequest {
  graph: EvmAddress!
}

input GraphRulesInput {
  unknownGraphRule: UnknownGraphRuleInput
}

input GraphsRequest {
  app: EvmAddress
  limit: Int
  cursor: Cursor
}

input HasReactedRequest {
  type: PostReactionType
}

input HideManagedAccountRequest {
  account: EvmAddress!
}

input HideReplyRequest {
  postId: PostId!
}

scalar IdToken

type ImageMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  image: MediaImage!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional image title."""
  title: String
  content: Encryptable!
}

type InvalidUsername {
  reason: String!
}

input IsFollowedByMeRequest {
  graph: EvmAddress!
}

input IsFollowingMeRequest {
  graph: EvmAddress!
}

type KnownAction {
  name: String!
  contract: NetworkAddress!
  setupInput: [ActionInputInfo!]!
  actionInput: [ActionInputInfo!]!
  returnSetupInput: [ActionInputInfo!]!
}

input LastLoggedInAccountRequest {
  address: EvmAddress!
  app: EvmAddress
}

scalar LegacyProfileId

scalar LegacyRefreshToken

type LinkMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """The sharing link url."""
  sharingLink: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

type LitProtocolEncryptionStrategy {
  accessCondition: TopLevelAccessCondition!
  encryptedPaths: [String!]!
  encryptionKey: String!
}

type LivestreamMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """
  The data cannot be changed so you can put in an API endpoint to know if it is still live or
  not for clients to be able to check.
  """
  checkLiveApi: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """The optional stream end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)"""
  endsAt: Encryptable

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!

  """
  Some livestream platforms have the live url as a separate url. If not your case make sure
  `liveUrl` and `playbackUrl` are the same.
  """
  liveUrl: Encryptable!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """
  Some livestream platforms have the playback url as a separate url. If not your case make
  sure `liveUrl` and `playbackUrl` are the same.
  """
  playbackUrl: Encryptable!

  """The stream start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The livestream title."""
  title: String
  content: Encryptable!
}

scalar Locale

type LoggedInAccountOperations {
  id: ID!

  """
  Check if the target account is followed by the authenticated account.
  
  If a graph is not specified:
  - It first checks for a Graph address specified within the query scope.
  - If no Graph address is found, it defaults to using the Global Graph.
  """
  isFollowedByMe(request: IsFollowedByMeRequest): Boolean!

  """
  Check if the authenticated account is following the target account.
  
  If a graph is not specified:
  - It first checks for a Graph address specified within the query scope.
  - If no Graph address is found, it defaults to using the Global Graph.
  """
  isFollowingMe(request: IsFollowingMeRequest): Boolean!

  """
  Check if the authenticated account can follow the target account.
  
  If a graph is not specified:
  - It first checks for a Graph address specified within the query scope.
  - If no Graph address is found, it defaults to using the Global Graph.
  """
  canFollow(request: CanFollowRequest): TriStateValue!

  """
  Check if the authenticated account can unfollow the target account.
  
  If a graph is not specified:
  - It first checks for a Graph address specified within the query scope.
  - If no Graph address is found, it defaults to using the Global Graph.
  """
  canUnfollow(request: CanUnfollowRequest): Boolean!
  isMutedByMe: Boolean!
  isBlockedByMe: Boolean!
  hasBlockedMe: Boolean!
  canBlock: Boolean!
  canUnblock: Boolean!
  hasReported: Boolean!
}

type LoggedInPostOperations {
  id: ID!
  isNotInterested: Boolean!
  hasBookmarked: Boolean!
  hasReported: Boolean!
  hasReacted(request: HasReactedRequest): Boolean!
  canComment: TriStateValue!
  canQuote: TriStateValue!
  canRepost: TriStateValue!
  hasCommented: BooleanValue!
  hasQuoted: BooleanValue!
  hasReposted: BooleanValue!
}

enum ManagedAccountsVisibility {
  NONE_HIDDEN
  HIDDEN_ONLY
  ALL
}

"""
MediaAudio

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"artist": {
"description": "The name of the artist.",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"cover": {
"$ref": "#/$defs/EncryptableUri"
},
"credits": {
"description": "The credits for the audio.",
"$ref": "#/$defs/EncryptableString"
},
"duration": {
"description": "How long the the audio is in seconds.",
"type": "integer",
"exclusiveMinimum": 0.0
},
"genre": {
"description": "The genre of the audio",
"$ref": "#/$defs/EncryptableString"
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"kind": {
"description": "The type of audio.",
"type": "string",
"enum": [
"MUSIC",
"PODCAST",
"AUDIOBOOK",
"VOICE_NOTE",
"SOUND",
"OTHER"
]
},
"license": {
"description": "The license for the audio.",
"$ref": "#/$defs/MetadataLicenseType"
},
"lyrics": {
"$ref": "#/$defs/EncryptableUri"
},
"recordLabel": {
"description": "The record label for the audio.",
"$ref": "#/$defs/EncryptableString"
},
"type": {
"description": "The mime type of the audio file.",
"type": "string",
"enum": [
"audio/wav",
"audio/vnd.wave",
"audio/mpeg",
"audio/ogg",
"audio/mp4",
"audio/aac",
"audio/webm",
"audio/flac"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaAudio {
  """The name of the artist."""
  artist: Encryptable

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  cover: Encryptable

  """The credits for the audio."""
  credits: Encryptable

  """How long the the audio is in seconds."""
  duration: Int

  """The genre of the audio"""
  genre: Encryptable
  item: Encryptable!

  """The type of audio."""
  kind: MediaAudioKind

  """The license for the audio."""
  license: MetadataLicenseType
  lyrics: Encryptable

  """The record label for the audio."""
  recordLabel: Encryptable

  """The mime type of the audio file."""
  type: MediaAudioType!
}

"""
The type of audio.

<details><summary>JSON schema</summary>

```json
{
"description": "The type of audio.",
"type": "string",
"enum": [
"MUSIC",
"PODCAST",
"AUDIOBOOK",
"VOICE_NOTE",
"SOUND",
"OTHER"
]
}
```
</details>
"""
enum MediaAudioKind {
  MUSIC
  PODCAST
  AUDIOBOOK
  VOICE_NOTE
  SOUND
  OTHER
}

"""
The mime type of the audio file.

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the audio file.",
"type": "string",
"enum": [
"audio/wav",
"audio/vnd.wave",
"audio/mpeg",
"audio/ogg",
"audio/mp4",
"audio/aac",
"audio/webm",
"audio/flac"
]
}
```
</details>
"""
enum MediaAudioType {
  AUDIO_WAV
  AUDIO_VND_WAVE
  AUDIO_MPEG
  AUDIO_OGG
  AUDIO_MP_4
  AUDIO_AAC
  AUDIO_WEBM
  AUDIO_FLAC
}

"""
MediaImage

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"altTag": {
"description": "The alt tag for accessibility",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"license": {
"description": "The license for the image",
"$ref": "#/$defs/MetadataLicenseType"
},
"type": {
"description": "The mime type of the image",
"type": "string",
"enum": [
"image/bmp",
"image/gif",
"image/heic",
"image/jpeg",
"image/png",
"image/svg+xml",
"image/tiff",
"image/webp",
"image/x-ms-bmp"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaImage {
  """The alt tag for accessibility"""
  altTag: Encryptable

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  item: Encryptable!

  """The license for the image"""
  license: MetadataLicenseType

  """The mime type of the image"""
  type: MediaImageType!
}

"""
The mime type of the image

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the image",
"type": "string",
"enum": [
"image/bmp",
"image/gif",
"image/heic",
"image/jpeg",
"image/png",
"image/svg+xml",
"image/tiff",
"image/webp",
"image/x-ms-bmp"
]
}
```
</details>
"""
enum MediaImageType {
  BMP
  GIF
  HEIC
  JPEG
  PNG
  SVG_XML
  TIFF
  WEBP
  X_MS_BMP
}

"""
MediaVideo

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"altTag": {
"description": "The alt tag for accessibility",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"cover": {
"$ref": "#/$defs/EncryptableUri"
},
"duration": {
"description": "How long the the video is in seconds",
"type": "integer",
"exclusiveMinimum": 0.0
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"license": {
"description": "The license for the video",
"$ref": "#/$defs/MetadataLicenseType"
},
"type": {
"description": "The mime type of the video",
"type": "string",
"enum": [
"model/gltf+json",
"model/gltf-binary",
"video/x-m4v",
"video/mov",
"video/mp4",
"video/mpeg",
"video/ogg",
"video/ogv",
"video/quicktime",
"video/webm"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaVideo {
  """The alt tag for accessibility"""
  altTag: Encryptable

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  cover: Encryptable

  """How long the the video is in seconds"""
  duration: Int
  item: Encryptable!

  """The license for the video"""
  license: MetadataLicenseType

  """The mime type of the video"""
  type: MediaVideoType!
}

"""
The mime type of the video

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the video",
"type": "string",
"enum": [
"model/gltf+json",
"model/gltf-binary",
"video/x-m4v",
"video/mov",
"video/mp4",
"video/mpeg",
"video/ogg",
"video/ogv",
"video/quicktime",
"video/webm"
]
}
```
</details>
"""
enum MediaVideoType {
  MODEL_GLTF_JSON
  MODEL_GLTF_BINARY
  VIDEO_XM_4V
  VIDEO_MOV
  VIDEO_MP_4
  VIDEO_MPEG
  VIDEO_OGG
  VIDEO_OGV
  VIDEO_QUICKTIME
  VIDEO_WEBM
}

type MetadataAttribute {
  type: MetadataAttributeType!
  key: String!
  value: String!
}

enum MetadataAttributeType {
  BOOLEAN
  DATE
  NUMBER
  STRING
  JSON
}

scalar MetadataId

enum MetadataLicenseType {
  CCO
  CC_BY
  CC_BY_ND
  CC_BY_NC
  TBNL_CD_PL_LEGAL
  TBNL_C_DT_PL_LEGAL
  TBNL_C_ND_PL_LEGAL
  TBNL_CD_NPL_LEGAL
  TBNL_C_DT_NPL_LEGAL
  TBNL_C_DTSA_PL_LEGAL
  TBNL_C_DTSA_NPL_LEGAL
  TBNL_C_ND_NPL_LEGAL
  TBNL_CD_PL_LEDGER
  TBNL_C_DT_PL_LEDGER
  TBNL_C_ND_PL_LEDGER
  TBNL_CD_NPL_LEDGER
  TBNL_C_DT_NPL_LEDGER
  TBNL_C_DTSA_PL_LEDGER
  TBNL_C_DTSA_NPL_LEDGER
  TBNL_C_ND_NPL_LEDGER
  TBNL_NC_D_PL_LEGAL
  TBNL_NC_DT_PL_LEGAL
  TBNL_NC_ND_PL_LEGAL
  TBNL_NC_D_NPL_LEGAL
  TBNL_NC_DT_NPL_LEGAL
  TBNL_NC_DTSA_PL_LEGAL
  TBNL_NC_DTSA_NPL_LEGAL
  TBNL_NC_ND_NPL_LEGAL
  TBNL_NC_D_PL_LEDGER
  TBNL_NC_DT_PL_LEDGER
  TBNL_NC_ND_PL_LEDGER
  TBNL_NC_D_NPL_LEDGER
  TBNL_NC_DT_NPL_LEDGER
  TBNL_NC_DTSA_PL_LEDGER
  TBNL_NC_DTSA_NPL_LEDGER
  TBNL_NC_ND_NPL_LEDGER
}

type MintMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """
  The mint item it can be a URL of the known provider like opensea https://opensea.io/assets/ethereum/0xfaa2471e93bd1cee3b0ab381c242ada8e1d1a759/299 or https://zora.co/collect/0x9d90669665607f08005cae4a7098143f554c59ef/39626. The Lens API has an allow list of providers and if the domain does not match it will mark it as failed metadata
  """
  mintLink: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

input MlaccountRecommendationsRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  shuffle: Boolean
}

input MlexplorePostsFilter {
  since: Int
}

input MlexplorePostsRequest {
  limit: Int
  cursor: Cursor
  filter: MlexplorePostsFilter
}

input MlpostsForYouRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  shuffle: Boolean
}

type ModFollowerResult {
  createdAt: DateTime!
  follower: Account!
  following: Account!
}

type ModReport {
  createdAt: DateTime!
  reporter: Account!
  reportedAccount: Account!
  reportedPost: Post
  reason: String!
  subreason: String!
  additionalInfo: String
}

input ModReportsRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress
  postId: PostId
}

type Mutation {
  """
  Report an account.
  
  You MUST be authenticated to use this mutation.
  """
  reportAccount(request: ReportAccountRequest!): Void!
  hideManagedAccount(request: HideManagedAccountRequest!): Void!
  unhideManagedAccount(request: UnhideManagedAccountRequest!): Void!

  """
  Set the metadata for the authenticated account.
  
  You MUST be authenticated to use this mutation.
  """
  setAccountMetadata(request: SetAccountMetadataRequest!): SetAccountMetadataResult!
  block(request: BlockRequest!): BlockResult!
  unblock(request: UnblockRequest!): UnblockResult!
  recommendAccount(request: RecommendAccount!): Void!
  undoRecommendedAccount(request: UndoRecommendedAccount!): Void!
  mute(request: MuteRequest!): Void!
  unmute(request: UnmuteRequest!): Void!

  """
  Create an account with a given username.
  
  You MUST be authenticated to use this mutation.
  """
  createAccountWithUsername(request: CreateAccountWithUsernameRequest!): CreateAccountWithUsernameResult!

  """Authenticate the user with the signed authentication challenge."""
  authenticate(request: SignedAuthChallenge!): AuthenticationResult!

  """
  Generate a new authentication challenge for the given account and app.
  
  The HTTP Origin header MUST be present and match the app's domain.
  """
  challenge(request: ChallengeRequest!): AuthenticationChallenge!

  """
  Revoke an authentication.
  
  You MUST be authenticated to use this mutation.
  """
  revokeAuthentication(request: RevokeAuthenticationRequest!): Void!

  """You MUST be authenticated to use this mutation."""
  switchAccount(request: SwitchAccountRequest!): SwitchAccountResult!
  refresh(request: RefreshRequest!): RefreshResult!

  """
  Issue new authentication tokens from a valid Lens API v2 refresh token.
  
  Use this to seamlessly transition your users from Lens API v2 to Lens API v3 without
  requiring them to re-authenticate.
  
  The HTTP Origin header MUST be present and match the app's domain.
  """
  rolloverRefresh(request: RolloverRefreshRequest!): RefreshResult!

  """
  Create a new post.
  
  You MUST be authenticated to use this mutation.
  """
  post(request: CreatePostRequest!): PostResult!

  """
  Repost a post.
  
  You MUST be authenticated to use this mutation.
  """
  repost(request: CreateRepostRequest!): PostResult!

  """
  Delete a post.
  
  You MUST be authenticated to use this mutation.
  """
  deletePost(request: DeletePostRequest!): DeletePostResult!

  """
  Edit a post.
  
  You MUST be authenticated to use this mutation.
  """
  editPost(request: EditPostRequest!): PostResult!

  """
  Bookmark a post.
  
  You MUST be authenticated to use this mutation.
  """
  bookmarkPost(request: BookmarkPostRequest!): Void!

  """
  Undo bookmark.
  
  You MUST be authenticated to use this mutation.
  """
  undoBookmarkPost(request: BookmarkPostRequest!): Void!
  hideReply(request: HideReplyRequest!): Void!
  unhideReply(request: UnhideReplyRequest!): Void!

  """
  React to a post.
  
  You MUST be authenticated to use this mutation.
  """
  addReaction(request: AddReactionRequest!): AddReactionResult!

  """
  Undo reaction to a post.
  
  You MUST be authenticated to use this mutation.
  """
  undoReaction(request: UndoReactionRequest!): UndoReactionResult!

  """
  Report a post.
  
  You MUST be authenticated to use this mutation.
  """
  reportPost(request: ReportPostRequest!): Void!

  """
  Follow an Account on the global Graph or a specific Graph.
  
  You MUST be authenticated to use this mutation.
  """
  follow(request: CreateFollowRequest!): FollowResult!

  """
  Unfollow an Account on the global Graph or a specific Graph.
  
  You MUST be authenticated to use this mutation.
  """
  unfollow(request: CreateUnfollowRequest!): UnfollowResult!
  setAccountFollowRule(request: CreateAccountFollowRuleRequest!): AccountFollowRuleResult!
  assignUsernameToAccount(request: AssignUsernameToAccountRequest!): AssignUsernameToAccountResult!
  unassignUsernameFromAccount: UnassignUsernameFromAccountResult!
  mlDismissRecommendedAccounts(request: DismissRecommendedAccountsRequest!): Void!
  mlAddPostNotInterested(request: PostNotInterestedRequest!): Void!
  mlUndoPostNotInterested(request: PostNotInterestedRequest!): Void!
  signFrameAction(request: FrameLensManagerEIP712Request!): FrameLensManagerSignatureResult!
}

input MuteRequest {
  account: EvmAddress!
}

union NestedPost = Post | PostReference

type NetworkAddress {
  address: EvmAddress!
  chainId: Int!
}

enum NftContractType {
  ERC_721
  ERC_1155
}

type NftOwnershipCondition {
  contract: NetworkAddress!
  contractType: NftContractType!

  """
  A list of token IDs you want to check ownership of. The list is optional for ERC721, you
  MUST provide a list of token IDs for ERC1155.
  """
  tokenIds: [String!]!
  type: String!
}

"""The existence of the transaction is not yet indexed. Keep trying."""
type NotIndexedYetStatus {
  reason: String!

  """True if the transaction has been mined."""
  txHasMined: Boolean!
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedAccountManagersResult {
  items: [AccountManager!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsBlockedResult {
  items: [AccountBlocked!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsManagedResult {
  items: [AccountManaged!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsResult {
  items: [Account!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedActions {
  items: [ActionInfo!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedActiveAuthenticationsResult {
  items: [ActiveAuthentication!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAppsResult {
  items: [App!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedCurrenciesResult {
  items: [Erc20!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedDisputedReports {
  items: [DisputedReport!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFollowRules {
  items: [FollowRule!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedGraphsResult {
  items: [Graph!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedModFollowersResult {
  items: [ModFollowerResult!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedModReports {
  items: [ModReport!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostReactionsResult {
  items: [AccountPostReaction!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostTagsResult {
  items: [Tag!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostsForYouResult {
  items: [PostForYou!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostsResult {
  items: [Post!]!
  pageInfo: PaginatedResultInfo!
}

input PaginatedQuery {
  pageSize: PageSize
  cursor: Cursor
}

type PaginatedResultInfo {
  prev: Cursor
  next: Cursor
}

type PaginatedTimelineResult {
  items: [TimelineItem!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUsernamesResult {
  items: [AccountUsername!]!
  pageInfo: PaginatedResultInfo!
}

type PaymasterParams {
  """The address of the paymaster."""
  paymaster: EvmAddress!

  """The bytestream input for the paymaster."""
  paymasterInput: BlockchainData!
}

"""
The existence of the transaction is known, but its status is not yet known.

The transaction could be:
- waiting to be included in a block
- waiting for a block to be mined
- waiting to be indexed by the Lens Indexer
- waiting for any associated metadata to be snapshotted and indexed
"""
type PendingTransactionStatus {
  blockTimestamp: DateTime!
}

"""PhysicalAddress"""
type PhysicalAddress {
  """The country name component."""
  country: Encryptable!

  """The full mailing address formatted for display."""
  formatted: Encryptable

  """The city or locality."""
  locality: Encryptable!

  """The zip or postal code."""
  postalCode: Encryptable

  """The state or region."""
  region: Encryptable

  """
  The street address including house number, street name, P.O. Box, apartment or unit number
  and extended multi-line address information.
  """
  streetAddress: Encryptable
}

type Post {
  id: PostId!
  author: Account!
  feed: Feed!
  timestamp: DateTime!
  app: App
  metadata: PostMetadata!
  root: NestedPost
  quoteOf: NestedPost
  commentOn: NestedPost
  actions: [PostAction!]!
  operations: LoggedInPostOperations
}

input PostAccountPair {
  postId: PostId!
  account: EvmAddress!
}

union PostAction = SimpleCollectActionSettings | UnknownActionSettings

enum PostActionCategoryType {
  COLLECT
}

input PostActionInput {
  collectAction: CollectActionInput!
  unknownAction: UnknownActionInput!
}

enum PostActionType {
  SIMPLE_COLLECT_ACTION
  UNKNOWN_ACTION
}

input PostActionsRequest {
  limit: Int
  cursor: Cursor
  includeUnknown: Boolean
  includeOnlyCollectActions: Boolean
  onlyVerified: Boolean
}

input PostBookmarksFilter {
  metadata: PostMetadataFilter
}

input PostBookmarksRequest {
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  filter: PostBookmarksFilter
  pageSize: PageSize
  cursor: Cursor
}

enum PostContentWarningType {
  NSFW
  SENSITIVE
  SPOILER
}

type PostForYou {
  post: Post!
  source: ForYouSource!
}

scalar PostId

enum PostMainContentFocus {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  FILE
}

union PostMetadata = ArticleMetadata | AudioMetadata | CheckingInMetadata | EmbedMetadata | EventMetadata | ImageMetadata | LinkMetadata | LivestreamMetadata | MintMetadata | SpaceMetadata | StoryMetadata | TextOnlyMetadata | ThreeDMetadata | TransactionMetadata | VideoMetadata

input PostMetadataContentWarningFilter {
  oneOf: [PostContentWarningType!]!
}

input PostMetadataFilter {
  """The main focus of the post."""
  mainContentFocus: [PostMainContentFocus!]

  """The tags to filter by."""
  tags: PostMetadataTagsFilter

  """The content warning to filter by."""
  contentWarning: PostMetadataContentWarningFilter
}

input PostMetadataTagsFilter {
  oneOf: [String!]
  all: [String!]
}

input PostNotInterestedRequest {
  postId: PostId!
}

type PostReaction {
  reaction: PostReactionType!
  reactedAt: DateTime!
}

enum PostReactionOrderBy {
  DEFAULT
  ACCOUNT_SCORE
}

type PostReactionStatus {
  postId: PostId!
  account: EvmAddress!
  result: Boolean!
}

input PostReactionStatusRequest {
  pairs: [PostAccountPair!]!
  filter: PostReactionsFilter
}

enum PostReactionType {
  UPVOTE
  DOWNVOTE
}

input PostReactionsFilter {
  """The types of reactions to filter by."""
  anyOf: [PostReactionType!]
}

input PostReactionsRequest {
  """The ID of the post to get reactions for."""
  postId: PostId!

  """An optional filter to narrow down the result."""
  filter: PostReactionsFilter

  """The order in which to return the results."""
  orderBy: PostReactionOrderBy
  pageSize: PageSize
  cursor: Cursor
}

type PostReference {
  id: PostId!
}

enum PostReferenceType {
  COMMENT_ON
  REPOST_OF
  QUOTE_OF
}

input PostReferencesRequest {
  referencePostId: PostId!
  referenceTypes: [PostReferenceType!]!
  pageSize: PageSize
  cursor: Cursor
}

enum PostReportReason {
  ANIMAL_ABUSE
  HARASSMENT
  VIOLENCE
  SELF_HARM
  DIRECT_THREAT
  HATE_SPEECH
  NUDITY
  OFFENSIVE
  SCAM
  UNAUTHORIZED_SALE
  IMPERSONATION
  MISLEADING
  MISUSE_HASHTAGS
  UNRELATED
  REPETITIVE
  FAKE_ENGAGEMENT
  MANIPULATION_ALGO
  SOMETHING_ELSE
}

input PostRequest {
  postId: PostId!
}

type PostResponse {
  hash: TxHash!
}

union PostResult = PostResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

enum PostTagsOrderBy {
  MOST_POPULAR
  ALPHABETICAL
}

input PostTagsRequest {
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  orderBy: PostTagsOrderBy! = MOST_POPULAR
  pageSize: PageSize
  cursor: Cursor
}

enum PostType {
  ROOT
  COMMENT
  REPOST
  QUOTE
}

input PostsFilterRequest {
  authors: [EvmAddress!]
  postTypes: [PostType!]
  metadata: PostMetadataFilter
  apps: [EvmAddress!]
}

input PostsRequest {
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  filter: PostsFilterRequest
  pageSize: PageSize
  cursor: Cursor
}

"""ProfileOwnershipCondition"""
type ProfileOwnershipCondition {
  profileId: EvmAddress!
  type: String!
}

type Query {
  health: Boolean!
  account(request: AccountRequest!): Account
  accounts(request: AccountsRequest!): [Account!]!
  accountStats(request: AccountStatsRequest!): AccountStats!
  accountGraphsStats(request: AccountGraphsStatsRequest!): AccountGraphsFollowStats!
  accountFeedsStats(request: AccountFeedsStatsRequest!): AccountFeedsStats!
  whoReferencedPost(request: WhoReferencedPostRequest!): PaginatedAccountsResult!
  whoActedOnPost(request: WhoActedOnPostRequest!): PaginatedAccountsResult!
  accountsBlocked(request: AccountsBlockedRequest!): PaginatedAccountsBlockedResult!
  accountsManaged(request: AccountsManagedRequest!): PaginatedAccountsManagedResult!
  accountManagers(request: AccountManagersRequest!): PaginatedAccountManagersResult!
  accountUsernames(request: AccountUsernameRequest!): PaginatedUsernamesResult!
  accountSponsorLimit(request: AccountSponsorRequest!): AccountSponsorResult!
  searchAccounts(request: AccountSearchRequest!): PaginatedAccountsResult!
  lastLoggedInAccount(request: LastLoggedInAccountRequest!): Account
  app(request: AppRequest!): App
  apps(request: AppsRequest!): PaginatedAppsResult!
  accountAuthentications(request: AccountAuthenticationsRequest!): PaginatedActiveAuthenticationsResult!

  """
  Get the current authentication for the user's request.
  
  You MUST be authenticated to use this query.
  """
  currentAuthentication: ActiveAuthentication!
  feed(request: FeedRequest!): Feed
  post(request: PostRequest!): AnyPost
  posts(request: PostsRequest!): PaginatedPostsResult!
  postReferences(request: PostReferencesRequest!): PaginatedPostsResult!
  postTags(request: PostTagsRequest!): PaginatedPostTagsResult!
  postBookmarks(request: PostBookmarksRequest!): PaginatedPostsResult!

  """Get the reactions added to a post."""
  postReactions(request: PostReactionsRequest!): PaginatedPostReactionsResult!
  postReactionStatus(request: PostReactionStatusRequest!): [PostReactionStatus!]!
  searchPosts(request: SearchPostsRequest!): PaginatedPostsResult!
  postActions(request: PostActionsRequest!): PaginatedActions!
  following(request: FollowingRequest!): PaginatedAccountsResult!
  followers(request: FollowersRequest!): PaginatedAccountsResult!
  followersYouKnow(request: FollowersYouKnowRequest!): PaginatedAccountsResult!
  followStatus(request: FollowStatusRequest!): [FollowStatusResult!]!
  graph(request: GraphRequest!): Graph
  graphs(request: GraphsRequest!): PaginatedGraphsResult!
  followRules(request: FollowRulesRequest!): PaginatedFollowRules!
  currencies(request: CurrencyRequest!): PaginatedCurrenciesResult!
  timeline(request: TimelineRequest!): PaginatedTimelineResult!
  timelineHighlights(request: TimelineHighlightsRequest!): PaginatedPostsResult!
  mlAccountRecommendations(request: MlaccountRecommendationsRequest!): PaginatedAccountsResult!
  mlPostsForYou(request: MlpostsForYouRequest!): PaginatedPostsForYouResult!
  mlPostsExplore(request: MlexplorePostsRequest!): PaginatedPostsResult

  """Get the status of a transaction by its hash."""
  transactionStatus(request: TransactionStatusRequest!): TransactionStatusResult!
  debugMetadata(request: DebugPostMetadataRequest!): DebugPostMetadataResult!
  debugTransactionStatusFailed(request: DebugTransactionStatusRequest!): DebugTransactionStatusResult
  createFrameTypedData(request: FrameEIP712Request!): CreateFrameEIP712TypedData!
  verifyFrameSignature(request: FrameVerifySignature!): FrameVerifySignatureResult!
  modFollowersHistory(request: PaginatedQuery!): PaginatedModFollowersResult!
  modLatestReports(request: ModReportsRequest!): PaginatedModReports!
  modDisputedReports(request: PaginatedQuery!): PaginatedDisputedReports!
  _service: _Service!
}

input RecipientDataInput {
  recipient: EvmAddress!
  split: Float!
}

type RecipientDataOutput {
  recipient: EvmAddress!
  split: Float!
}

input RecommendAccount {
  account: EvmAddress!
}

input ReferencingPostInput {
  """The post to reference."""
  post: PostId!
}

input RefreshRequest {
  refreshToken: RefreshToken!
}

union RefreshResult = AuthenticationTokens | ForbiddenError

scalar RefreshToken

input ReportAccountRequest {
  account: EvmAddress!
  reason: AccountReportReason!
  additionalComment: String
  referencePosts: [PostId!]
}

input ReportPostRequest {
  postId: PostId!
  reason: PostReportReason!
  additionalComment: String
}

type Repost {
  id: PostId!
  author: Account!
  timestamp: DateTime!
  app: App
  repostOf: Post!
}

input RevokeAuthenticationRequest {
  authenticationId: UUID!
}

input RolloverRefreshRequest {
  """The app that new tokens will be issued for."""
  app: EvmAddress!

  """A valid Lens API v2 refresh token for a Profile session."""
  refreshToken: LegacyRefreshToken!
}

input SearchPostsFilter {
  """The post types to filter by."""
  postTypes: [PostType!]

  """The optional metadata filter."""
  metadata: PostMetadataFilter
}

input SearchPostsRequest {
  """
  The query text to search for in the post content or metadata tags.
  The passed strings supports web search syntax similar to the search engines:
  - individual words match independently.
  - double-quoted phrases match as a single unit.
  - the word or (case-insensitive) specifies an “or” condition between two words or phrases
  - a "-" prefix specifies to not match the following word or phrase.
  """
  query: String!

  """The feeds to search in."""
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]

  """The optional post types to filter by."""
  filter: SearchPostsFilter
  pageSize: PageSize
  cursor: Cursor
}

type SelfFundedTransactionRequest {
  """
  The encoded EIP-1559 transaction request.
  
  Use a parser to decode this data into a transaction request object
  for your library (e.g., ethers, viem).
  """
  encoded: EncodedTransaction!

  """
  The raw transaction request object.
  
  Use this object if your library does not have a parser for the encoded transaction data.
  """
  raw: Eip1559TransactionRequest!
}

type SetAccountFollowRuleResponse {
  hash: TxHash!
}

input SetAccountMetadataRequest {
  metadataUri: URI!
}

type SetAccountMetadataResponse {
  hash: TxHash!
}

union SetAccountMetadataResult = SetAccountMetadataResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

scalar Signature

input SignedAuthChallenge {
  id: UUID!
  signature: Signature!
}

input SimpleCollectActionInput {
  amount: AmountInput
  referralFee: Float
  recipient: EvmAddress
  collectLimit: String
  followerOnly: Boolean!
  endsAt: DateTime
  recipients: [RecipientDataInput!]
}

type SimpleCollectActionSettings {
  type: PostActionType!
  contract: NetworkAddress!
  amount: Amount!
  collectNft: EvmAddress
  collectLimit: String
  followerOnly: Boolean!
  recipient: EvmAddress!
  referralFee: Float!
  endsAt: DateTime
  recipients: [RecipientDataOutput!]!
}

type SpaceMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!

  """The space join link."""
  link: Encryptable!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """The space start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The space title."""
  title: String!
  content: Encryptable!
}

enum SponsorLimitType {
  HOUR
  DAY
  WEEK
  MONTH
}

type SponsoredTransactionRequest {
  """
  The encoded EIP-712 transaction request.
  
  Use a parser that supports ZKsync EIP-712 transaction to decode this data into a
  transaction request object for your library (e.g., zksync/ethers, viem/zksync).
  """
  encoded: EncodedTransaction!

  """
  The raw transaction request object.
  
  Use this object if your library does not have a parser for the encoded transaction data.
  """
  raw: Eip712TransactionRequest!
}

type StoryMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The story asset."""
  asset: AnyMedia!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

input SwitchAccountRequest {
  account: EvmAddress!
}

union SwitchAccountResult = AuthenticationTokens | ForbiddenError

scalar Tag

type TextOnlyMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  content: Encryptable!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]
}

type ThreeDAsset {
  """The 3D format of the asset."""
  format: ThreeDAssetFormat!

  """The license regulating the use of the 3D asset."""
  license: MetadataLicenseType

  """
  The URL of the recommended web based 3D player to use to view the 3D asset.
  """
  playerUrl: URI!

  """The URI of the 3D asset zip file."""
  uri: URI!

  """Path in extracted zip. Relative. 3D start point, MUST be 3D file type."""
  zipPath: String
}

enum ThreeDAssetFormat {
  G_LTF_GLB
  FBX
  VRM
  OBJ
}

type ThreeDMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The 3D items for the publication"""
  assets: [ThreeDAsset!]!

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

enum TimelineEventItemType {
  POST
  COMMENT
  MIRROR
  QUOTE
}

input TimelineFilter {
  eventType: [TimelineEventItemType!]
  metadata: PostMetadataFilter
}

input TimelineHighlightsFilter {
  eventType: [TimelineEventItemType!]
  metadata: PostMetadataFilter
}

input TimelineHighlightsRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  filter: TimelineHighlightsFilter
}

type TimelineItem {
  id: String!
  primary: Post!
  mirrors: [Post!]!
  comments: [Post!]!
}

input TimelineRequest {
  cursor: Cursor
  account: EvmAddress!
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  filter: TimelineFilter
}

"""AccessCondition"""
type TopLevelAccessCondition {
  criteria: [AnyAccessCondition!]!
  type: String!
}

type TransactionMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """The Chain Id."""
  chainId: ChainId!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The transaction hash."""
  txHash: Encryptable!

  """The type of transaction."""
  type: TransactionType!
  content: Encryptable!
}

input TransactionStatusRequest {
  txHash: TxHash!
}

union TransactionStatusResult = PendingTransactionStatus | FinishedTransactionStatus | FailedTransactionStatus | NotIndexedYetStatus

enum TransactionType {
  ERC_721
  ERC_20
  OTHER
}

type TransactionWillFail {
  reason: String!
}

enum TriStateValue {
  YES
  NO
  UNKNOWN
}

scalar TxHash

scalar URI

scalar URL

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID @specifiedBy(url: "http://tools.ietf.org/html/rfc4122")

type UnassignUsernameFromAccountError {
  error: UnlinkUsernameFromAccountErrorType!
}

type UnassignUsernameFromAccountResponse {
  hash: TxHash!
}

union UnassignUsernameFromAccountResult = UnassignUsernameFromAccountResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | UnassignUsernameFromAccountError

type UnblockError {
  error: UnblockErrorType!
}

enum UnblockErrorType {
  UNKNOWN
  NOT_BLOCKED
  UNAUTHORIZED
}

input UnblockRequest {
  account: EvmAddress!
}

type UnblockResponse {
  hash: TxHash!
}

union UnblockResult = UnblockResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | UnblockError

type UndoReactionFailure {
  reason: String!
}

input UndoReactionRequest {
  """The reaction to add."""
  reaction: PostReactionType!

  """The post to react to."""
  postId: PostId!
}

type UndoReactionResponse {
  success: Boolean!
}

union UndoReactionResult = UndoReactionResponse | UndoReactionFailure

input UndoRecommendedAccount {
  account: EvmAddress!
}

type UnfollowResponse {
  hash: TxHash!
}

union UnfollowResult = UnfollowResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input UnhideManagedAccountRequest {
  account: EvmAddress!
}

input UnhideReplyRequest {
  postId: PostId!
}

type UnknownAction {
  name: String!
  contract: NetworkAddress!
}

input UnknownActionInput {
  address: EvmAddress!
  data: String!
}

type UnknownActionSettings {
  type: PostActionType!
  initializeCalldata: BlockchainData
  initializeResultData: BlockchainData
  verified: Boolean!
  contract: NetworkAddress!
  collectNft: EvmAddress
}

input UnknownFeedRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

input UnknownFollowRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

input UnknownGraphRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

enum UnlinkUsernameFromAccountErrorType {
  UNKNOWN
  USERNAME_NOT_LINKED
  UNAUTHORIZED
}

input UnmuteRequest {
  account: EvmAddress!
}

scalar UsernameValue

type VideoMetadata {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: VideoMetadataLensMainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional video title."""
  title: String
  video: MediaVideo!
  content: Encryptable!
}

enum VideoMetadataLensMainContentFocus {
  SHORT_VIDEO
  VIDEO
}

scalar Void

input WhoActedOnPostFilter {
  anyOf: [ActionFilter!]!
}

enum WhoActedOnPostOrderBy {
  LAST_ACTIONED
  FIRST_ACTIONED
  ACCOUNT_SCORE
}

input WhoActedOnPostRequest {
  postId: PostId!
  filter: WhoActedOnPostFilter
  orderBy: WhoActedOnPostOrderBy
  limit: Int
  cursor: Cursor
}

enum WhoReferencedPostOrderBy {
  LAST_ACTIONED
  FIRST_ACTIONED
  ACCOUNT_SCORE
}

input WhoReferencedPostRequest {
  postId: PostId!
  referenceTypes: [PostReferenceType!]
  orderBy: WhoReferencedPostOrderBy
  limit: Int
  cursor: Cursor
}

"""The signature was not signed by the expected signer."""
type WrongSignerError {
  reason: String!
}

type _Service {
  sdl: String
}